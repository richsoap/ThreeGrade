# 二叉树
## 定义
二叉树由节点的有限集合构成，这个有限集合或者为空集，或者为由一个根节点及两棵(左右子树)互不交叉的树结构组成
## 术语
### 根
唯一的起始节点
### 父节点
除了根节点之外的任何节点，都有且仅有一个父节点
### 子节点
任何节点都可以有两个子节点
### 兄弟节点
同一个父节点的节点
### 度
节点的子树的数目
### 叶节点
没有子节点
### 内部节点
非叶节点
### 边
父节点k,与子节点k'之间，存在一条有向连接<k,k'>
### 路径
从k0到ks都有首尾相连的边，则为一个路径，边的的个数才是路径的长度。k0叫做祖先，ks是子孙。
### 子树
断掉连接之后，形成以子节点为根节点的自树
### 层数
根节点到某个节点的路径长度
### 深度
层数最大的叶结点的层数
## 特殊二叉树
### 满二叉树
所有节点要么为叶节点，要么都有两个子节点
### 完全二叉树
只有最下面的两层节点度数可以小于2，而且最下面一层的节点都集中在最左边的连续位置上，则此二叉树称作完全二叉树(一层一层地从左向右挂满)
#### 特点
相同结点数下，根节点到所有结点的距离和最小。
### 扩充二叉树
在出现空子树的位置上，增加空树叶，所形成的二叉树。有多少个空子树，就添加多少个空树叶。
#### 外部路径长度
从根节点到每个外部节点的路径长度之和
#### 内部路径长度
从根节点到每个内部节点的路径长度之和
#### 性质
E=I+2n(n为内部节点数)
## 性质
### 第i层上最多有$2^i$个结点
### 深度为k的二叉树之多有$2&{k+1}-1$个结点
### 任何一棵二叉树，若其终端结点数为$n_0$，度为2的节点数为$n_2$,则$n_0=N_2+1$
对于任意一棵树，都有n=e+1,n为节点数，e为边数(除根结点外，都有一条连向父节点的边)

又有$e=n_1+2n_2,n=n_0+n_1+n_2$，带入即为所证
### 满二叉树定理:非空满二叉树树叶数目等于其分支结点数+1
### 有n个节点的完全二叉树的高度为$log_2(n+1)[深度为log_2(n+1)-1]$。
### 对于具有n个节点的完全二叉树，节点按层次，从左到右编号为i
* i=0，为根节点，否则其父节点编号为 $\frac{i-1}{2}$
* 当$2i+1\leq n-1$时，节点的左子节点为$2i+1$否则没有左子结点
* 当$2i+2\leq n-1$时，节点的左子节点为$2i+2$否则没有左子结点
* 当i为偶数时，节点的左兄弟结点是$i-1$(这是一个右结点)
* 当i为奇数时，且$i+1<n$时，结点的右兄弟结点是$i+1$(这是一个左结点)

## 二叉树的抽象数据类型
### 抽象数据类型
#### 要求
左右子结点，父结点，本身的数据
### 深度优先遍历
#### 前序
* 根结点
* 前序左子树
* 前序右子树
#### 中序
* 中序左子树
* 根结点
* 中序右子树
#### 后序
* 后序左子树
* 后序右子树
* 根结点
#### 算法
优先考虑递归，实在不行就用stack<br/>
前序:输出value右子结点压栈，访问左子树，左子树空，出栈
### 广度优先遍历
#### 队列
先将左右结点入队，输出当前节点，再出队
### 存储结构
#### 链式储存结构
各节点随机储存，节点之间用指针关联
##### 分类
二叉链表或者三叉链表(有没有parent)
#### 完全二叉树的顺序储存结构
因为知道结点数后，完全二叉树的结构也就定了，也就可以直接用数组(通过之前的编号规律)得到相应的父结点，子结点，兄弟结点
#### 操作
删除，记得用后序遍历
### 应用
#### 二叉搜索树(BST)
* 每个非空结点表示一个记录
* 左子树一定小于当前结点，右子树一定大于当前结点
##### 优势
查找时都是进行二分地操作，巨快
##### 操作
###### 插入
比较大小，考虑在什么地方进行插入操作
###### 删除
* 没有左子树，将右子树的根代替被删除的节点
* 有左子树，在左子树里，中序周游的最后的最后一个结点(最大的那个点)代替该结点(这样可以保持树的层数不至于突然变大)
## 堆
* 最小值堆:最小值堆是一个关键码的序列，有特性:$K_i\leq K_{2i+1},$,每个结点都小于子女，但未知子女关系。
### 建堆过程
先将内容都放到一维数组中，看作一个没有排序好的完全二叉树。再用筛选法建堆。
### 优势
同一数据集，多次查找最小值，效率最高
## Huffman
带权外部路径长度:深度*数值

总的带权外部路径长度最小的树，就是Huffman树
### 构造
每次都选择最小的两个根结点，构成一个棵新树，新的根结点的值是左右两个子结点的值的和
