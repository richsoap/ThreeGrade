# 排序
## 基本概念
* 记录：结点，进行排序的基本单位
* 关键码：唯一确定记录的一个或多个域
* 排序码：作为排序运算依据的一个或多个域
* 序列，由记录构成的线性表
* 不增序，不减序
* 正序，逆序
* 稳定性：多个具有相同排序码的记录排序后次序不变
## 衡量标准
* 时间代价：记录的比较和移动次数
* 空间代价
## 算法
### 插入排序
#### 直接插入排序
* 前i个元素已经排好序，将第i+1个元素前比该元素大的都往后移动一位，确定第i+1个元素应该在的位置
* 稳定
* 空间代价:$\Theta(1)$
* 时间代价:最好 $比较n-1，移动2(n-1)移动\Theta(n)$，最差 $比较一次就要交换一次，\Theta(n^2)$，平均$\Theta(n^2)$
#### Shell排序
* 将序列分割成小序列(每 $\Delta$ 个元素构成一个序列)，再在内部进行排序，并逐渐减少小序列个数，最后再在大序列里排一次，即可
* 不稳定
* 空间$\Theta(1)$
* 时间$\Theta(n^2)$，选择增量合适可以让时间代价接近$\Theta(n)$
### 选择排序
#### 直接选择排序
* 依次选出最小，塞进输出序列
* 不稳定
* 空间代价 $\Theta(1)$
* 时间代价 $\Theta(n^2)$[比较$\Theta(n^2)$,交换n-1,总代价$\Theta(n^2)$]
#### 堆排序
* 用最大/最小值堆进行排序
* 建堆用时$\Theta(n)$
* 出堆$\Theta(logi)$
* 一次建堆，n次出堆
* 总用时$\Theta(n+nlogn)=\Theta(nlogn)$
* 空间代价$\Theta(1)$
### 交换排序
#### 冒泡排序
* 不停地比较相邻记录，不满足条件就交换，直到所有记录都排好
* 优化思路：减少比较次数
* 稳定
* 空间$\Theta(1)$
* 时间$\Theta(n^2)$
#### 快速排序
* 使用分治思想，将序列分为L和R两个子序列，对L和R进行递归快排
* 对于长度为n的序列，时间为T(n)
* 选取轴值为O(1)
* 分割时间为cn
* 对子序列进行快排用时T(i)和T(n-1-i)
* 递归方程:T(n)=T(i)+T(n-1-i)+cn
* 最坏情况，变成直接选择，T(n)=T(n-1)+cn，求和得，总用时$\Theta(n^2)$，空间$\Theta(n)$
* 最好情况，全部二分，T(n)=2T(n/2)+cn，求和得，总用时$\Theta(nlogn)$，空间$\Theta(logn)$
* 平均情况，设分成各个长度的概率都相同，有nT(n)=(n+1)T(n-1)+2cn-c，$\Theta(nlogn)$，空间$\Theta(logn)$
* 不稳定
### 归并排序？？？？
* 简单将原始序列分为两个子序列
* 分别对连个子序列递归排序
* 最后将排好序的子序列合并为有序序列
* 稳定
* 时间：划分时间，子序列排序时间，归并时间
* 空间：$\Theta(n)$
* 时间：$\Theta(nlogn)$，且不依赖于原始数据输入情况，最大，最小，平均时间都是nlogn
### 分配排序和基数排序
#### 桶排序
* 将数据归并，再对归并后的桶进行排序，适用于多重复元素的排序
#### 基数排序
* 先按照排序码进行桶排序[先对个位桶排，再对十位，等等等，得到一层层嵌套的排过序的桶]
* 高位优先法(MSD)：分分分分分……收
* 低位排序法(LSD)：分收，分收……分收（利用了对于第d位相同的元素，其会按照第d-1位排序的特点）
* 空间：临时数组，n，计数器r，总共$\Theta(n+r)$
* 时间：一次桶排，花费$\Theta(n+r)$，重复d次，总共用时$\Theta(d(n+r))$
## 时间代价分析
* 基于比较的排序算法，最差情况下需要进行$log(n!)$即$\Omega(nlogn)$次比较
