# 排序
## 基本概念
* 记录：结点，进行排序的基本单位
* 关键码：唯一确定记录的一个或多个域
* 排序码：作为排序运算依据的一个或多个域
* 序列，由记录构成的线性表
* 不增序，不减序
* 正序，逆序
* 稳定性：多个具有相同排序码的记录排序后次序不变
## 衡量标准
* 时间代价：记录的比较和移动次数
* 空间代价
## 算法
### 插入排序
#### 直接插入排序
* 前i个元素已经排好序，将第i+1个元素前比该元素大的都往后移动一位，确定第i+1个元素应该在的位置
* 稳定
* 空间代价:$\Theta(1)$
* 时间代价:最好 $比较n-1，移动2(n-1)移动\Theta(n)$，最差 $比较一次就要交换一次，\Theta(n^2)$，平均$\Theta(n^2)$
#### Shell排序
* 将序列分割成小序列(每 $\Delta$ 个元素构成一个序列)，再在内部进行排序，并逐渐减少小序列个数，最后再在大序列里排一次，即可
* 不稳定
* 空间$\Theta(1)$
* 时间$\Theta(n^2)$，选择增量合适可以让时间代价接近$\Theta(n)$
### 选择排序
#### 直接选择排序
* 依次选出最小，塞进输出序列
* 不稳定
* 空间代价 $\Theta(1)$
* 时间代价 $\Theta(n^2)$[比较$\Theta(n^2)$,交换n-1,总代价$\Theta(n^2)$]
#### 堆排序
* 用最大/最小值堆进行排序
* 建堆用时$\Theta(n)$
* 出堆$\Theta(logi)$
* 一次建堆，n次出堆
* 总用时$\Theta(n+nlogn)=\Theta(nlogn)$
* 空间代价$\Theta(1)$
### 交换排序
#### 冒泡排序
* 不停地比较相邻记录，不满足条件就交换，直到所有记录都排好
* 优化思路：减少比较次数
* 稳定
* 空间$\Theta(1)$
* 时间$\Theta(n^2)$
#### 快速排序
* 使用分治思想，将序列分为L和R两个子序列，对L和R进行递归快排
* 对于长度为n的序列，时间为T(n)
* 选取轴值为O(1)
* 分割时间为cn
* 对子序列进行快排用时T(i)和T(n-1-i)
* 递归方程:T(n)=T(i)+T(n-1-i)+cn
* 最坏情况，变成直接选择，T(n)=T(n-1)+cn，求和得，总用时$\Theta(n^2)$，空间$\Theta(n)$
* 最好情况，全部二分，T(n)=2T(n/2)+cn，求和得，总用时$\Theta(nlogn)$，空间$\Theta(logn)$
* 平均情况，设分成各个长度的概率都相同，有nT(n)=(n+1)T(n-1)+2cn-c，$\Theta(nlogn)$，空间$\Theta(logn)$
* 不稳定
### 归并排序
* 简单将原始序列分为两个子序列
* 分别对连个子序列递归排序
* 最后将排好序的子序列合并为有序序列
