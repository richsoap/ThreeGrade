# 检索
## 概念
* 检索：在一组记录集合中找到关键码值等于给定值的记录的过程
## 常用方法
* 预排序
* 建立索引
* 散列技术
* B树
## 指标
* 平均检索长度：$ASL=\sum^n_{i=1}P_iC_i$
## 线性表的检索
### 顺序检索
* 逐个比较
* 可以查顺序，链接
* 要求：无
* 平均检索长度：$成功后的平均长度\frac{n+1}{2}，失败后的平均长度(n+1)则，\frac{n+1}{2}<ASL<n+1$
* 优点：插入元素方便
### 二分检索
* 将任一元素与给定的K比较，进行二分查找
* 平均检索长度:$ASL\approx log_2(n+1)-1$
* 优点，速度快
* 缺点：要排序，数据更新不方便
### 分块检索
* 将数据分块，线性表共有n个数据元素，将表分为b块，不需要均匀，不需要满
* 但前一块中的最大关键码必须要续后一块中的最小关键码
* 用二分法查快，用顺序法查内部
* 平均检索长度：$ASL\approx\sqrt{n},s=\sqrt{n}$
* 优点：插入删除容易，没有大量记录移动
* 缺点，增加辅助数组，初始化线性表分块排序，大量插入/删除/结点分布不均匀时性能不佳
## 集合的检索
### 位向量
* 密集型集合：数据范围小，集合中有效元素多
## 散列的检索
### 想法
用算法直接由key算出目标位置
### 概念
* 负载因子：$\alpha=\frac{n}{m}$，n为填入表中的节点数，m为散列表的空间总大小
* 冲突：不同关键码计算出相同地址
* 同义词：发生冲突的两个关键码
### 考虑的问题
* 如何构造散列函数
* 解决冲突
* 散列表本身的结构
### 散列函数
* 运算简单
* 值域要在表长范围内
* 避免冲突
#### 常用方法
* 除余法：关键码MOD散列表。分布不均，不用幂，不用偶数。
* 乘余取整法：关键码key乘上一个常数A，提取乘积的小数部分，再用整数n乘以这个地址，对结果向下取整
* 平方取中法：先将关键码平方，再取其中几位或其组合
* 数字分析法：设有n个d位数，每一位有r种不同的符号，且出现概率不一定相同。根据散列表的大小，选取其中各种符号分布均匀的若干位作为散列地址。这是完全依赖于关键码的集合，关键码一换，选择方法也要换
* 基数转换法：关键码是另外一进制的数，再将其进制换回去，取若干位，一般去大于原来基数的数作为转换基数，且两基数要互素
* 折叠法：将关键码分割，再将这几部分进行叠加(移位叠加，分界叠加)
## 碰撞处理
### 开散列法(拉链法)
* 把发生冲突的关键码存在散列表主表之外，即碰撞发生，就建立一个链表
* 在内存中性能影响不大
* 不适合用于外存，但可以使用桶式散列
#### 桶式散列
* 适合存储于磁盘的散列表
* 散列函数得到的不再是地址，而是桶号
### 闭散列法(开地址法)
* 把发生出土的关键码存在另外一个槽内
* 当冲突发生时，就用关键码生成一个散列地址序列，存在后续散列地址中
* 若所有后续散列地址都不空闲，说明该散列表已满，报告溢出
#### 检索过程
* 重复冲突解决过程，找出符合条件的记录
#### 常见闭散列方法
##### 线性探查
* 若该地址被占用，就将地址加一，存入下一个地址
* 优点：表中所有存储位置都可以被利用
* 问题：聚集/堆积：散列地址不同的结点，都争夺同一后继地址，导致探查序列变得非常长
* 改进：每次跳过c个位置，而不是1个，但并不能从根本解决问题
##### 二次探查
* 探查增量为$(-)^{i-1}i^2$
##### 伪随机数
* 生成一个固定的伪随机序列作为增量数组，避免不同基地址的序列堆在一起
* 问题：二级聚集，由于该增量和关键码无关，所以只要基地址一样了，后续还是会得到相同序列
##### 双散列探查法
* 使用第二个散列函数计算增量
* 要求：新函数得到的值必须和数组长度互素，否则没有意义(又回到了起点)
### 闭散列表的算法实现
#### 字典
* 一种特殊的集合，其元素是(关键码，属性值)二元组。
* 关键码必须是互不相同的(至少在同一字典内)
* 插入：地址未被占用，插入；冲突处理也找不到位置，报告无空间；找到关键码相同：相同数据无需插入两次；
* 检索：地址为空，记录不存在；关键码相等，检索成功；关键码不相等，找下一个地址
* 删除：删除的时候不能影响后续的检索，释放的存储位置还要能够为将来插入使用；开散列能够删除；闭散列只能作墓碑
#### 墓碑
* 用于标记一个记录曾经存在，而现在不用了的情况
* 插入：如果有墓碑，就优先插入到墓碑处
* 删除：将元素标记为墓碑
* 查找：即使找到墓碑也要继续搜索
